---
title: "Case Study: Casual inference for observational data using modelbased"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Case Study: Casual inference for observational data using modelbased}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: bibliography.bib
---

```{r set-options, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  dev = "png",
  out.width = "100%",
  dpi = 300,
  message = FALSE,
  warning = FALSE
)

options(modelbased_join_dots = FALSE)
options(modelbased_select = "minimal")

pkgs <- c("glmmTMB", "marginaleffects")

if (!all(vapply(pkgs, requireNamespace, quietly = TRUE, FUN.VALUE = logical(1L)))) {
  knitr::opts_chunk$set(eval = FALSE)
}
if (!getRversion() >= "4.1.0") {
  knitr::opts_chunk$set(eval = FALSE)
}
```

This vignette demonstrates how to perform causal inference with observational data using the `modelbased` package. While the examples below use the terms "treatment" and "control" groups, these labels are arbitrary and interchangeable. Causal inference can be applied to any scenario where observations are assigned to different conditions, regardless of whether a "treatment" in the medical sense is involved.

## The lack of randomization

Randomized controlled trials (RCTs) are frequently employed to estimate the average treatment effect (ATE), which represents the average difference in outcomes between individuals in the treatment and control groups. In the context of RCTs, the ATE can be interpreted as a causal effect.

Estimating causal effects with observational data, where treatment and control group assignments are not randomized, presents a greater challenge due to the potential for confounding bias. In observational studies, individual characteristics associated with the outcome (e.g., age, gender, education, health status) are likely unequally distributed between the treatment and control groups. This imbalance violates a key assumption for causal effect estimation, an assumption typically satisfied by randomization in RCTs but often unmet in observational data.

## Propensity scores and G-computation

Two primary methods exist for addressing the lack of randomization in observational data: propensity scores and g-computation. Regarding propensity scores, this vignette focuses on _inverse probability weighting_ (IPW), a common technique for estimating propensity scores [@chatton_causal_2024; @gabriel_inverse_2024].

IPW assigns weights to individual observations to reflect their contribution to the outcome under the assumption of exchangeability between groups. When specific characteristics are over-represented in the treatment group, IPW assigns lower weights to these individuals, thereby adjusting for the imbalanced distribution of confounders between treatment and control groups.

G-computation, rooted in the traditional methods of stratification and standardization, addresses confounding in observational studies by partitioning the study population into strata, calculating stratum-specific outcomes, and then weighting these outcomes to represent a target population (e.g., the general population). In _modelbased_, g-computation can be implemented by setting `estimate = "population"`. This approach directly models counterfactual scenarios by creating copies of each observation, effectively assigning each individual to both treatment and control conditions. The final estimate is then derived by averaging predictions across these counterfactual observations [@dickerman_counterfactual_2020].

```{r}
# example
library(modelbased)
library(datawizard)
library(parameters)
data(qol_cancer, package = "parameters")
qol_cancer$time <- as.factor(qol_cancer$time)

set.seed(123)
d <- qol_cancer |>
  data_arrange("ID") |>
  data_group("ID") |>
  data_modify(treatment = rbinom(1, 1, 0.3)) |>
  data_ungroup()

d$treatment <- as.factor(d$treatment)

m <- glm(
  treatment ~ time + hospital + phq4 + education + age,
  data = d,
  family = binomial()
)

d$predictions <- predict(m, newdata = d, type = "response")
d$wts <- ifelse(d$treatment == 1, 1 / d$predictions, 1 / (1 - d$predictions))

# no interaction - no need for contrasts
m_simple1 <- glmmTMB::glmmTMB(
  QoL ~ treatment + time + education + hospital + age + phq4 + (1 | ID),
  data = d
)

m_simple2 <- glmmTMB::glmmTMB(
  QoL ~ treatment + time + education + hospital + age + phq4 + (1 | ID),
  weights = wts,
  data = d
)
# simple case, no interaction. ATE directly extractable from coefficient table
compare_parameters(m_simple1, m_simple2, keep = "^treatment")

# 1. no need for contrasts
# 2. no difference if G-computation is applied or not
estimate_contrasts(m_simple1, "treatment")
estimate_contrasts(m_simple2, "treatment")

estimate_contrasts(m_simple1, "treatment", estimate = "population")
estimate_contrasts(m_simple2, "treatment", estimate = "population")


# interaction terms involved
m1 <- glmmTMB::glmmTMB(
  QoL ~ treatment * time + education + hospital + age + phq4 + (1 | ID),
  data = d
)

m2 <- glmmTMB::glmmTMB(
  QoL ~ treatment * time + education + hospital + age + phq4 + (1 | ID),
  weights = wts,
  data = d
)

# ATE no longer visible from coefficient table
parameters::compare_parameters(m1, m2, keep = "^treatment")

# still no difference for G-computation or not
modelbased::estimate_contrasts(m1, "treatment")
modelbased::estimate_contrasts(m1, "treatment", estimate = "population")

# better with IPW
modelbased::estimate_contrasts(m2, "treatment")
modelbased::estimate_contrasts(m2, "treatment", estimate = "population")



# more complex model
m3 <- glmmTMB::glmmTMB(
  QoL ~ treatment * time + treatment * education + hospital + age + phq4 + (1 | ID),
  data = d
)

m4 <- glmmTMB::glmmTMB(
  QoL ~ treatment * time + treatment * education + hospital + age + phq4 + (1 | ID),
  weights = wts,
  data = d
)

# complex model, no IPW, G-computation is more accurate!
modelbased::estimate_contrasts(m3, "treatment")
modelbased::estimate_contrasts(m3, "treatment", estimate = "population")

# complex model, with IPW *and* G-computation (double-robust) is more accurate!
modelbased::estimate_contrasts(m4, "treatment")
modelbased::estimate_contrasts(m4, "treatment", estimate = "population")
```
