---
title: "Mixed models"
output:
  rmarkdown::html_vignette:
    toc: true
tags: [r, programing]
vignette: >
  \usepackage[utf8]{inputenc}
  %\VignetteIndexEntry{Mixed models}
  %\VignetteEngine{knitr::rmarkdown}
bibliography: bibliography.bib
---

```{r set-options, echo = FALSE, message = FALSE}
library(knitr)
knitr::opts_chunk$set(
  package.startup.message = FALSE,
  dpi = 300,
  collapse = TRUE,
  comment = "#>",
  warning = FALSE,
  message = TRUE
)
options(
  knitr.kable.NA = "",
  digits = 2,
  width = 800,
  modelbased_join_dots = FALSE,
  modelbased_select = "minimal"
)
pkgs <- c("lme4", "marginaleffects", "collapse", "Formula", "palmerpenguins")
successfully_loaded <- suppressPackageStartupMessages(vapply(pkgs, requireNamespace, FUN.VALUE = logical(1L), quietly = TRUE))
can_evaluate <- all(successfully_loaded)

if (can_evaluate) {
  knitr::opts_chunk$set(eval = TRUE)
  junk <- suppressMessages(suppressPackageStartupMessages(vapply(pkgs, require, FUN.VALUE = logical(1L), quietly = TRUE, character.only = TRUE)))
} else {
  knitr::opts_chunk$set(eval = FALSE)
}
```

## Estimated Marginal Means in Mixed Models: Navigating Conditional and Marginal Effects

Mixed models, with their ability to account for hierarchical or clustered data, offer powerful tools for understanding complex relationships. A key aspect of interpreting these models is understanding **estimated marginal means (EMMs)**, which represent the predicted outcome for specific groups or conditions, while holding other variables constant. However, calculating EMMs in mixed models is not always straightforward, and the results can vary depending on the approach taken.

One crucial distinction is between **conditional** and **marginal** predictions (or effects). Conditional predictions are specific to a particular level of the random effect (e.g., the predicted outcome for a specific individual in a study). Marginal predictions, on the other hand, average over the random effects, providing an overall estimate of the effect in the population. This is a crucial difference, as the marginal effect is often the quantity of interest when we want to generalize to the population [@heiss_marginal_2022].

To use the summaries from Heiss (2022):

> This conditional vs. marginal distinction applies to any sort of hierarchical structure in multilevel models:
>
> - **Conditional effect** = the effect of a variable in an *average cluster* (i.e. group-specific, subject-specific or cluster-specific effect, or an average or a typical cluster)
> - **Marginal effect** = effect of a variable *across clusters on average* (i.e. global/population-level effect, or clusters on average).

When working with mixed models, the `modelbased` package offers flexibility in calculating EMMs through different backends. The `"marginaleffects"` backend and the `"emmeans"` backend are two popular choices, but they employ different underlying methodologies. **marginaleffects** typically focuses on marginal predictions by averaging over the random effects, while **emmeans** provides conditional predictions. Consequently, the EMMs obtained using these two backends may differ. As we will see, conditional and marginal predictions...

- ... are usually similar for linear mixed models
- ... are usually different for generalized linear mixed models
- ... are usually different for both linear and generalized linear models, when the data is "imbalanced" and "average" predictions are requested (i.e. `estimate = "average"`); by _imbalanced_ we mean not equally distributed levels.

In essence, the choice of backend and the understanding of whether we are looking at conditional or marginal predictions are critical for correctly interpreting the results of mixed models. Carefully considering the research question and the nature of the random effects will guide the selection of the appropriate approach.

> **Technical Note:**
>
> For `backend = "marginaleffects"`, the `re.form` argument is set to `NULL` for mixed models by default, to calculate _marginal predictions_. You can use for instance `re.form = NA` in your `estimate_means()` call to change the default value (`NA` will produce _conditional predictions_).

This vignette shows some examples to demonstrate where results are similar and where they differ.

## Linear mixed models

### Balanced Data

This section demonstrates the calculation of estimated marginal means (EMMs) in a linear mixed model using balanced data. We'll use the `sleepstudy` dataset from the **lme4** package.

In this example, we fit a linear mixed model predicting `Reaction` based on `Days`, with random intercepts and slopes for `Subject`. We then calculate the EMMs for `Days` using both the default `"marginaleffects"` backend and the `"emmeans"` backend. Because the data is balanced and we have a linear, the results are similar.

```{r}
library(modelbased)
data(sleepstudy, package = "lme4")
# for later, create a slightly imbalanced distributed predictor
set.seed(1234)
sleepstudy$x <- as.factor(sample.int(3, nrow(sleepstudy), replace = TRUE))

model <- lme4::lmer(Reaction ~ Days + (1 + Days | Subject), data = sleepstudy)

# default, marginaleffects backend (marginal predictions)
# in this case, same result as for conditional predictions
estimate_means(model, "Days")

# emmeans backend, always conditional predictions
estimate_means(model, "Days", backend = "emmeans")
```

Here, we calculate the marginal predictions for the `Days` variable using the `estimate = "average"` argument. In this case, because the model is linear and the data is balanced, the predictions are again the same as the previous results, i.e. averaging across all observations makes no difference here.

```{r}
# marginal predictions, same as conditional predictions
estimate_means(model, "Days", estimate = "average")
```

### Imbalanced Data

This section explores the impact of imbalanced data on EMM calculations in linear mixed models. We'll use the `penguins` dataset, which has imbalanced groups that we use as higher unit, as well as imbalanced predictors.

```{r}

data(penguins, package = "palmerpenguins")
model <- lme4::lmer(bill_length_mm  ~ bill_depth_mm + sex + island   + (1 | species), data = penguins)

estimate_means(model, "sex")
estimate_means(model, "sex", re.form = NA)
estimate_means(model, "sex", backend = "emmeans")

estimate_means(model, "sex", estimate = "average")
estimate_means(model, "sex", estimate = "average", re.form = NA)

estimate_means(model, "bill_depth_mm")
estimate_means(model, "bill_depth_mm", re.form = NA)
estimate_means(model, "bill_depth_mm", backend = "emmeans")

estimate_means(model, "bill_depth_mm", estimate = "average")
estimate_means(model, "bill_depth_mm", estimate = "average", re.form = NA)
```


```{r}
data("fish", package = "insight")
m1 <- lme4::glmer(
  count ~ child + camper + (1 | persons),
  data = fish,
  family = poisson()
)

estimate_means(m1, "camper")
estimate_means(m1, "camper", re.form = NA)
estimate_means(m1, "camper", backend = "emmeans")

estimate_means(m1, "camper", estimate = "average")


m2 <- glm(
  count ~ child + camper,
  data = fish,
  family = poisson()
)

estimate_means(m2, "camper")
estimate_means(m2, "camper", backend = "emmeans")

estimate_means(m2, "camper", estimate = "average")
```

# References
